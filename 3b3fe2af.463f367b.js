(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{119:function(e,t,c){"use strict";c.d(t,"a",(function(){return p})),c.d(t,"b",(function(){return m}));var n=c(0),l=c.n(n);function a(e,t,c){return t in e?Object.defineProperty(e,t,{value:c,enumerable:!0,configurable:!0,writable:!0}):e[t]=c,e}function r(e,t){var c=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),c.push.apply(c,n)}return c}function o(e){for(var t=1;t<arguments.length;t++){var c=null!=arguments[t]?arguments[t]:{};t%2?r(Object(c),!0).forEach((function(t){a(e,t,c[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(c)):r(Object(c)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(c,t))}))}return e}function s(e,t){if(null==e)return{};var c,n,l=function(e,t){if(null==e)return{};var c,n,l={},a=Object.keys(e);for(n=0;n<a.length;n++)c=a[n],t.indexOf(c)>=0||(l[c]=e[c]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)c=a[n],t.indexOf(c)>=0||Object.prototype.propertyIsEnumerable.call(e,c)&&(l[c]=e[c])}return l}var i=l.a.createContext({}),b=function(e){var t=l.a.useContext(i),c=t;return e&&(c="function"==typeof e?e(t):o(o({},t),e)),c},p=function(e){var t=b(e.components);return l.a.createElement(i.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},u=l.a.forwardRef((function(e,t){var c=e.components,n=e.mdxType,a=e.originalType,r=e.parentName,i=s(e,["components","mdxType","originalType","parentName"]),p=b(c),u=n,m=p["".concat(r,".").concat(u)]||p[u]||d[u]||a;return c?l.a.createElement(m,o(o({ref:t},i),{},{components:c})):l.a.createElement(m,o({ref:t},i))}));function m(e,t){var c=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=c.length,r=new Array(a);r[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,r[1]=o;for(var i=2;i<a;i++)r[i]=c[i];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,c)}u.displayName="MDXCreateElement"},82:function(e,t,c){"use strict";c.r(t),c.d(t,"frontMatter",(function(){return r})),c.d(t,"metadata",(function(){return o})),c.d(t,"toc",(function(){return s})),c.d(t,"default",(function(){return b}));var n=c(3),l=c(7),a=(c(0),c(119)),r={id:"querycells",title:"Query on Cells"},o={unversionedId:"tutorials/querycells",id:"tutorials/querycells",isDocsHomePage:!1,title:"Query on Cells",description:"A Cell is the most basic structure that represents a single piece of data in Nervos. The data contained in a Cell can take many forms, including CKBytes, tokens, code like JavaScript code, or even serialized data like JSON strings.",source:"@site/docs\\tutorials\\querycells.md",slug:"/tutorials/querycells",permalink:"/lumos_doc/docs/tutorials/querycells",editUrl:"https://github.com/xying21/lumos_doc/tree/master/docs/tutorials/querycells.md",version:"current",sidebar:"someSidebar",previous:{title:"Set Up the Lumos Indexer",permalink:"/lumos_doc/docs/tutorials/indexer"},next:{title:"Query on Transactions",permalink:"/lumos_doc/docs/tutorials/querytransactions"}},s=[{value:"Indexer.collector Function",id:"indexercollector-function",children:[]},{value:"CellCollector Class",id:"cellcollector-class",children:[]},{value:"Examples",id:"examples",children:[{value:"Query Cells by Lock Script",id:"query-cells-by-lock-script",children:[]},{value:"Query Cells by Specific <code>lock</code> and <code>type</code> Script",id:"query-cells-by-specific-lock-and-type-script",children:[]},{value:"Query Cells between Given Block Numbers",id:"query-cells-between-given-block-numbers",children:[]},{value:"Skip Cells",id:"skip-cells",children:[]},{value:"Prefix Search on <code>args</code>",id:"prefix-search-on-args",children:[]},{value:"Fine Grained Query for Cells",id:"fine-grained-query-for-cells",children:[]},{value:"Order Cells by Block Number",id:"order-cells-by-block-number",children:[]},{value:"Get the Cell Minimal Capacity",id:"get-the-cell-minimal-capacity",children:[]},{value:"Get the Mainnet Address from a Lock Script",id:"get-the-mainnet-address-from-a-lock-script",children:[]},{value:"Generate the Testnet Address from a Lock Script",id:"generate-the-testnet-address-from-a-lock-script",children:[]},{value:"Get the Lock Script from an Address",id:"get-the-lock-script-from-an-address",children:[]},{value:"Get the Balance of an Account",id:"get-the-balance-of-an-account",children:[]},{value:"Get Uncommitted Cells",id:"get-uncommitted-cells",children:[]}]}],i={toc:s};function b(e){var t=e.components,c=Object(l.a)(e,["components"]);return Object(a.b)("wrapper",Object(n.a)({},i,c,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"A Cell is the most basic structure that represents a single piece of data in Nervos. The data contained in a Cell can take many forms, including CKBytes, tokens, code like JavaScript code, or even serialized data like JSON strings."),Object(a.b)("p",null,"For more information about the cell model, see ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://docs.nervos.org/docs/reference/cell"}),"Cell Data Structure")," and ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0002-ckb/0002-ckb.md#42-cell"}),"CKB RFC"),"."),Object(a.b)("p",null,"A CKB DApp must have query functions on cells that are the fundamental functions to support user queries and transaction requests. Lumos provides convenient query functions with the support of the ",Object(a.b)("inlineCode",{parentName:"p"},"Indexer")," and ",Object(a.b)("inlineCode",{parentName:"p"},"CellCollector")," classes."),Object(a.b)("h2",{id:"indexercollector-function"},"Indexer.collector Function"),Object(a.b)("p",null,"The ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/indexer/lib/index.js#L242"}),"Indexer.collector")," function can be used to collect cells according to specific query options and returns the cells as the result."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Constructor"),":"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},'collector({ lock = null, type = null, argsLen = -1, data = "any", fromBlock = null, toBlock = null, skip = null }')),Object(a.b)("h2",{id:"cellcollector-class"},"CellCollector Class"),Object(a.b)("p",null,"The ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/indexer/lib/index.js#L324"}),"CellCollector")," class also supports query on cells, and it has the order query option to order the result by block numbers."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Constructor"),":"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},'{  indexer, {lock = null, type = null, argsLen = -1, data = "any", fromBlock = null,  toBlock = null, order = "asc",  skip = null,}}')),Object(a.b)("h2",{id:"examples"},"Examples"),Object(a.b)("h3",{id:"query-cells-by-lock-script"},"Query Cells by Lock Script"),Object(a.b)("p",null,"The following example collects the cells for a specific lock script."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'import {INDEXER} from "./index";\nimport { Cell, Script } from "@ckb-lumos/base";\n\nexport const findCellsbylock = async (\n    lockScript: Script,\n  ): Promise<Cell[]> => {\n \n  const collector = INDEXER.collector({ lock:lockScript});\n  const cells: Cell[] = [];\n  console.log("Find the cells by lock script:");\n  for await (const cell of collector.collect()) {\n      cells.push(cell);\n    }\n    return cells;\n  };\n')),Object(a.b)("p",null,"The indexer is started as follows:"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/index.ts"',title:'"hellolumos/src/index.ts"'}),'import { Indexer } from "@ckb-lumos/indexer";\nexport const CKB_RPC = "http://127.0.0.1:8114";\nexport const INDEXER = new Indexer(CKB_RPC, "./indexed-data");\nINDEXER.startForever();\n')),Object(a.b)("p",null,"Try the findCellsbylock(lockScript) function in the Node.js REPL mode:"),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),"$ cd hellolumos\n$ node --experimental-repl-await\nWelcome to Node.js v14.0.0.\nType \".help\" for more information.\n> const { accounts, querycells }=require(\".\");\nThe server is started.\n> const alice = accounts.ALICE;\n> const script={\n code_hash: \"0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8\",\n hash_type: \"type\",\n args: alice.ARGS,\n };\n> await querycells.findCellsbylock(script);\nFind the cells by lock script:\n[\n  {\n    cell_output: { capacity: '0x1247953509b2', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0xe8655b071e3eeb94d73c2307295bbe88431e74d9091bd8ec081404a9ac485251',\n      index: '0x0'\n    },\n    block_hash: '0x4feda2b0950c3137d4a2128cbe7b25f9dd255c3468007a6b10118f2fccd855bb',\n    block_number: '0x26',\n    data: '0x'\n  },\n  {\n    cell_output: { capacity: '0x124794cb65db', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0xd99327f73c6278589d59cde617982a08e3fabadefa18bbae14eab30fa89b9fb1',\n      index: '0x0'\n    },\n    block_hash: '0xe8016c14a198a2b9f7acd4964ec876527ff55082d6e3a210e7b73c6316f86690',\n    block_number: '0x27',\n    data: '0x'\n  },\n  {\n    cell_output: { capacity: '0x12479461c26d', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0x0b2ac03c909402057eabf4202ae3ee8fc65f9f6182837db2599c53d2cc8051ba',\n      index: '0x0'\n    },\n    block_hash: '0x19bb281bc4e53a76cce55a10b99abf82bc528b6eb37e72c9bd62cd520109a1a8',\n    block_number: '0x28',\n    data: '0x'\n  },\n  {\n    cell_output: { capacity: '0x124793f81f68', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0x432996588d8dd5ffdc5b502e464563b63715da43f983adfeeb174ec35154f003',\n      index: '0x0'\n    },\n    block_hash: '0xcf9d19ecf0257a7182ae5cc3c1b972f40cb856d8dd87c127e0561678c43f32ab',\n    block_number: '0x29',\n    data: '0x'\n  },\n...\n")))),Object(a.b)("h3",{id:"query-cells-by-specific-lock-and-type-script"},"Query Cells by Specific ",Object(a.b)("inlineCode",{parentName:"h3"},"lock")," and ",Object(a.b)("inlineCode",{parentName:"h3"},"type")," Script"),Object(a.b)("p",null,"The following example collects the cells for a specific lock script and type script, and returns the cells as the result."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'export async function findCellsbyLockandType(\n  lockScript: Script,\n  typeScript: Script\n): Promise<Cell[]>  {\n\nconst collector = INDEXER.collector({ lock:lockScript, type:typeScript});\nconst cells: Cell[] = [];\nconsole.log("Find the cells by Lock and Type script");\nfor await (const cell of collector.collect()) {\n    cells.push(cell);\n }\nreturn cells;\n};\n')),Object(a.b)("p",null,"Try the findCellsbyLockandType(lockScript, typeScript) function in the Node.js REPL mode:"),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),"> const { CONFIG }=require(\".\");\n> const template = CONFIG.SCRIPTS[\"DAO\"];\n> const typescript={\n code_hash: template.CODE_HASH,\n hash_type: template.HASH_TYPE,\n args: \"0x\",\n };\n> await querycells.findCellsbyLockandType(script,typescript);\nFind the cells by Lock and Type script\n[\n  {\n    cell_output: { capacity: '0x4a817c800', lock: [Object], type: [Object] },\n    out_point: {\n      tx_hash: '0x313378dc3ce2d5c3f3efd546bc9595b54907844c20a72adae15cb9e970ce90df',\n      index: '0x0'\n    },\n    block_hash: '0x657bef9f9d300bfd884065992f243770b9fa7dc8aafa304c98e210d2e02d1248',\n    block_number: '0x12c',\n    data: '0x6a00000000000000'\n  },\n  {\n    cell_output: { capacity: '0x4a817c800', lock: [Object], type: [Object] },\n    out_point: {\n      tx_hash: '0xbc708146e8fea53a4629d37fbd345f7e9dca79225d90bb1f73e7077ade93da19',\n      index: '0x0'\n    },\n    block_hash: '0xfc4a10116dbfb591796dcbf19e95c26ac647e7c2e41fc1b327a19c7ddd1eb938',\n    block_number: '0x135',\n    data: '0x1a01000000000000'\n  }\n]\n")))),Object(a.b)("h3",{id:"query-cells-between-given-block-numbers"},"Query Cells between Given Block Numbers"),Object(a.b)("p",null,"The following example fetches cells between ",Object(a.b)("inlineCode",{parentName:"p"},"[fromblock, toblock]"),". Both ",Object(a.b)("inlineCode",{parentName:"p"},"fromBlock")," and ",Object(a.b)("inlineCode",{parentName:"p"},"toBlock")," are included in the query options."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'export async function findCellsfromto (\n  lockScript: Script,\n  fromblock: string,\n  toblock: string\n): Promise<Cell[]> {\n\nconst collector = INDEXER.collector({ lock:lockScript, fromBlock:fromblock,toBlock:toblock});\nconst cells: Cell[] = [];\nconsole.log("Find cells from block",fromblock,"to block", toblock);\nfor await (const cell of collector.collect()) {\n    cells.push(cell);\n    console.log(cell);\n }\nreturn cells;\n}\n')),Object(a.b)("p",null,"Try the findCellsfromto(lockScript, fromblock, toblock) function in the Node.js REPL mode:"),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),"> const from = \"0x81\";\n> const to = \"0x83\";\n> await querycells.findCellsfromto(script,from,to);\nFind cells from block 0x81 to block 0x84\n[\n  {\n    cell_output: { capacity: '0x12476faec3ef', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0x4f6efa5ee4a116940d2dfe549c1e2ddac9ae02268d68d5e300fade7e8466072d',\n      index: '0x0'\n    },\n    block_hash: '0x6a8d2e35b024128c06cbf5ba551b6c7de576566fce12e61c646052e622f701d7',\n    block_number: '0x81',\n    data: '0x'\n  },\n  {\n    cell_output: { capacity: '0x12476fa0d2a2', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0xede91f58056a467cf5114a258ebc7a96a581e8e0a23fde083f84f833a6f0503c',\n      index: '0x0'\n    },\n    block_hash: '0xaefdfe2473ce86d137cbb9d2e7cf4f1f3600663bb18aa6e4d30518c6b3870be5',\n    block_number: '0x82',\n    data: '0x'\n  },\n  {\n    cell_output: { capacity: '0x12476edbf23a', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0x73c528726d7ca1cad5af6d7debdf962814f49994ef8ad686d071d8aac96e394c',\n      index: '0x0'\n    },\n    block_hash: '0x721d22c925d98b0260d9b6a647fdb6e93010f816f1158c14971a73c0cb073b60',\n    block_number: '0x83',\n    data: '0x'\n  },\n]\n")))),Object(a.b)("h3",{id:"skip-cells"},"Skip Cells"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"skip")," parameter represents the number of cells being skipped for the Lumos indexer. "),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'export async function findCellsandSkip(\n  lockScript: Script,\n  skip: number\n): Promise<Cell[]> {\n\nconst collector = INDEXER.collector({ lock:lockScript, skip:skip});\nconst cells: Cell[] = [];\nconsole.log("Find Cells and Skip the first",skip, "cells:");\nfor await (const cell of collector.collect()) {\n    cells.push(cell);\n    console.log(cell);\n }\nreturn cells;\n};\n')),Object(a.b)("p",null,"The following example skips the first 100 cells and returns the result from the 101st. cell."),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),">await querycells.findCellsandSkip(script,100);\n...\n")))),Object(a.b)("h3",{id:"prefix-search-on-args"},"Prefix Search on ",Object(a.b)("inlineCode",{parentName:"h3"},"args")),Object(a.b)("p",null,"The default ",Object(a.b)("inlineCode",{parentName:"p"},"argsLen")," is -1, that means the full slice of original args is passed in the query. You can specify argsLen with other values when the ",Object(a.b)("inlineCode",{parentName:"p"},"args")," field is the prefix of original args."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Note"),": It is recommended to specify explicit length for the ",Object(a.b)("inlineCode",{parentName:"p"},"argsLen")," parameter. For example, the length is 20 in normal scenarios and 28 in the multisig scenario for the lock script.  When the length is not certain, the ",Object(a.b)("inlineCode",{parentName:"p"},"argsLen")," parameter can be set as ",Object(a.b)("inlineCode",{parentName:"p"},"any"),". But there is performance lost when using ",Object(a.b)("inlineCode",{parentName:"p"},"any")," rather than explicit length."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'export async function findCellsbyPrefix(\n  lockScript: Script,\n  argslen:number\n): Promise<Cell[]>  {\n\nconst collector = INDEXER.collector({ lock:lockScript,argsLen:argslen});\nconst cells: Cell[] = [];\nconsole.log("Find Cells by prefix of args");\nfor await (const cell of collector.collect()) {\n    cells.push(cell);\n }\nreturn cells;\n};\n')),Object(a.b)("h3",{id:"fine-grained-query-for-cells"},"Fine Grained Query for Cells"),Object(a.b)("p",null,"Fine grained query for cells can be achieved by using ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/base/index.d.ts#L351"}),"ScriptWrapper")," with customized options like ",Object(a.b)("inlineCode",{parentName:"p"},"ioType"),", ",Object(a.b)("inlineCode",{parentName:"p"},"argsLen"),"."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"ioType")," field is among ",Object(a.b)("inlineCode",{parentName:"p"},"input | output | both"),"."),Object(a.b)("p",null,"If the ",Object(a.b)("inlineCode",{parentName:"p"},"argsLen")," is not specified in the function, the outside ",Object(a.b)("inlineCode",{parentName:"p"},"argsLen")," config or the default value -1 will be used."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'import { ScriptWrapper } from "@ckb-lumos/base";\nexport async function finegrainedsearch(\n  lockScript: Script,\n  typeScript: Script,\n  argslen: number\n): Promise<Cell[]> {\nconst lock:ScriptWrapper = {\n  script:lockScript,\n  argsLen: argslen\n}\nconst collector = INDEXER.collector({ lock:lock,type:typeScript});\nconst cells: Cell[] = [];\nconsole.log("Fine-Grained Query:");\nfor await (const cell of collector.collect()) {\n    cells.push(cell);\n }\nreturn cells;\n};\n')),Object(a.b)("p",null,"Try the finegrainedsearch(locScript, typeScript, argslen) function in Node.js REPL mode:"),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),'> const { CONFIG }=require(".");\n> const template = CONFIG.SCRIPTS["DAO"];\n> const typescript={\n   code_hash: template.CODE_HASH,\n   hash_type: template.HASH_TYPE,\n   args: "0x",\n   };\n> const argslen = 20;\n> await querycells.finegrainedsearch(script,typescript,argslen);\n...\n')))),Object(a.b)("h3",{id:"order-cells-by-block-number"},"Order Cells by Block Number"),Object(a.b)("p",null,"The following example creates a new ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/indexer/lib/index.js#L324"}),"CellCollector"),' and uses the CellCollector to collect cells in order of block numbers for a specific lock script. If the order is not specified, the default order is "asc" for the returned result.'),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'import { CellCollector } from "@ckb-lumos/indexer";\n\nexport async function findCellsinOrderofBlockNum (\n  lockScript: Script,\n  order:"asc"|"desc"\n): Promise<Cell[]> {\n    \nconst collector = new CellCollector(INDEXER, { lock:lockScript, order:order});\nconst cells: Cell[] = [];\nconsole.log("Find Cells in descending", order, "order of block numbers:");\nfor await (const cell of collector.collect()) {\n    cells.push(cell);\n }\nreturn cells;\n};\n')),Object(a.b)("p",null,"The following example gets the live cells for Alice and returns the result in descending order of block numbers."),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),"> const { accounts, querycells }=require(\".\");\n> const alice = accounts.ALICE;\n> const script={\n code_hash: \"0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8\",\n hash_type: \"type\",\n args: alice.ARGS,\n };\n> await querycells.findCellsinOrderofBlockNum(script,\"desc\");\nFind Cells in descending desc order of block numbers:\n[\n  {\n    cell_output: { capacity: '0x124462255f12', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0x53d845d810109d6ee4e94df96565100a4126c6fa671db1d237f60eca4a8d2105',\n      index: '0x0'\n    },\n    block_hash: '0x0301f7aa0c2902383e15662008f9886aa4cd628c4948ba737d13894e7334ea54',\n    block_number: '0x805',\n    data: '0x'\n  },\n  {\n    cell_output: { capacity: '0x1244628be0aa', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0xea8f658e6ea08c38f58f6a0af3530396aba0e51e1064db8626ecd38976625c34',\n      index: '0x0'\n    },\n    block_hash: '0xbae60c9c4f54d6f6a970fb76c2fdd226a83dd8724cff082157da559ce6cf507f',\n    block_number: '0x804',\n    data: '0x'\n  },\n  {\n    cell_output: { capacity: '0x1242ecee4f71', lock: [Object], type: undefined },\n    out_point: {\n      tx_hash: '0xe332fb6efba38e16b8fd20a4f47d5fffcf8fcac0c863b0eb30ef75067847936d',\n      index: '0x1'\n    },\n    block_hash: '0xd0c09a6615b30f685dd0b0e627021f89e0f35e9b59c575001d8a11f63436b76c',\n    block_number: '0x803',\n    data: '0x'\n  },\n...\n")))),Object(a.b)("h3",{id:"get-the-cell-minimal-capacity"},"Get the Cell Minimal Capacity"),Object(a.b)("p",null,"A CKB cell has three fields and itself all take up capacity. The cell must have the capacity that is equal or more than the total size of information stored in the cell. For more information, see ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://nervosnetwork.github.io/docs-new/docs/reference/cell"}),"Cell"),"."),Object(a.b)("p",null,"For example, the minimum CKB capacity requirement is 61 CKB (6100000000n) for one common transaction, and 102 CKB (10200000000n) for a DAO deposit transaction."),Object(a.b)("p",null,"The ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/helpers/src/index.ts#L44"}),"minimalCellCapacity(fullCell)")," function of the @ckb-lumos/helpers package can be used to get the minimal capacity for a cell."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'import { minimalCellCapacity } from "@ckb-lumos/helpers";\n\nexport async function getminimalCellCapacity(\n fullcell:Cell\n) {\n  console.log("The full cell is", fullcell);\n  const result = minimalCellCapacity(fullcell);\n  console.log("The minimal cell capacity is",result);\n};\n')),Object(a.b)("p",null,"Try the minimalCellCapacity(fullCell) function in the Node.js REPL mode:"),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),"> const { minimalCellCapacity }= require(\"@ckb-lumos/helpers\");\n> const fullcell= (await querycells.findCellsbylock(script))[0];\n> console.log(fullcell);\n{\n  cell_output: {\n    capacity: '0x1247953509b2',\n    lock: {\n      code_hash: '0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8',\n      hash_type: 'type',\n      args: '0x7e00660b8ab122bca3ba468c5b6eee71f40b7d8e'\n    },\n    type: undefined\n  },\n  out_point: {\n    tx_hash: '0xe8655b071e3eeb94d73c2307295bbe88431e74d9091bd8ec081404a9ac485251',\n    index: '0x0'\n  },\n  block_hash: '0x4feda2b0950c3137d4a2128cbe7b25f9dd255c3468007a6b10118f2fccd855bb',\n  block_number: '0x26',\n  data: '0x'\n}\n> const minimalcapacity = await minimalCellCapacity(fullcell);\n> console.log(minimalcapacity);\n6100000000n\n")))),Object(a.b)("h3",{id:"get-the-mainnet-address-from-a-lock-script"},"Get the Mainnet Address from a Lock Script"),Object(a.b)("p",null,"The ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/helpers/src/index.ts#L89"}),"generateAddress(script, {config})")," function of the @ckb-lumos/helpers package can be used to generate address for a specific lock script."),Object(a.b)("p",null,"The following example generates the mainnet address for a lock script."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'import {predefined} from "@ckb-lumos/config-manager";\nimport { generateAddress } from "@ckb-lumos/helpers";\n\nexport async function generateMainnetAddress(\n  lockScript:Script,\n)  {\n  const config = undefined || predefined.LINA;\n  const mainnetAddress = generateAddress(lockScript,{config});\n  console.log("The mainnet address for the lockscript is", mainnetAddress);  \n}\n')),Object(a.b)("p",null,"Try the generateMainnetAddress(lockScript) function in the Node.js REPL mode:"),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),"> const mainnet = await querycells.generateMainnetAddress(script);\nThe mainnet address for the lockscript is ckb1qyq8uqrxpw9tzg4u5waydrzmdmh8raqt0k8qxe85u4\n")))),Object(a.b)("h3",{id:"generate-the-testnet-address-from-a-lock-script"},"Generate the Testnet Address from a Lock Script"),Object(a.b)("p",null,"The following example generates the Testnet address for a lock script."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'export async function generateTestnetAddress(\n  lockScript:Script,\n)  {\n  const config = undefined || predefined.AGGRON4;\n  const testnetAddress = generateAddress(lockScript, {config});\n  console.log("The testnet address for the lockscript is", testnetAddress);  \n}\n')),Object(a.b)("p",null,"Try the generateTestnetAddress(lockScript) function in the Node.js REPL mode:"),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),"> const mainnet = await querycells.generateTestnetAddress(script);\nThe testnet address for the lockscript is ckt1qyq8uqrxpw9tzg4u5waydrzmdmh8raqt0k8qmuetsf\n")))),Object(a.b)("h3",{id:"get-the-lock-script-from-an-address"},"Get the Lock Script from an Address"),Object(a.b)("p",null,"The ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/helpers/src/index.ts#L145"}),"parseAddress (address)")," function of the @ckb-lumos/helpers package can be used to get the lock script from an address."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Example"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'export async function generatelockFromAddress (\n  address:Address\n)  {\n  const lockscript = parseAddress(address);\n  console.log("The lockscript of the address is", lockscript);  \n}\n')),Object(a.b)("p",null,"Try the parseAddress (address, {config}) function in the Node.js REPL mode: "),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),"> const { parseAddress } = require (\"@ckb-lumos/helpers\");\n> const lockscript = parseAddress(\"ckt1qyq8uqrxpw9tzg4u5waydrzmdmh8raqt0k8qmuetsf\");\n{\n  code_hash: '0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8',\n  hash_type: 'type',\n  args: '0x7e00660b8ab122bca3ba468c5b6eee71f40b7d8e'\n}\n")))),Object(a.b)("h3",{id:"get-the-balance-of-an-account"},"Get the Balance of an Account"),Object(a.b)("p",null,"The following example uses the ",Object(a.b)("inlineCode",{parentName:"p"},"Indexer.collector")," function to collect live cells for a specific lock script and then calculates the total capacity as the balance of the account. "),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'export async function getBalancebyLock (\n  lockScript:Script\n)  {\n  let balance = BigInt(0);\n  const collector = INDEXER.collector({ lock:lockScript});\n  const cells: Cell[] = [];\n \n  for await (const cell of collector.collect()) {\n      cells.push(cell);\n   }\n  balance = cells\n   .map((cell) =>\n     BigInt(\n       cell.cell_output.capacity\n     )\n   )\n   .reduce((balance, capacity) => (balance = balance += capacity));\n  console.log("The balance of the account is", balance);\n}\n')),Object(a.b)("p",null,"Try the getBalancebyLock(lockScript) function in the Node.js REPL mode:"),Object(a.b)("details",null,Object(a.b)("summary",null,"CLICK ME"),Object(a.b)("p",null,Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-shell"}),"> const balance = await querycells.getBalancebyLock(script);\nThe balance of the account is 41027155650775568n\n")))),Object(a.b)("h3",{id:"get-uncommitted-cells"},"Get Uncommitted Cells"),Object(a.b)("p",null,"There is one problem with UTXO based blockchains: pending transactions require a certain amount of period before the transactions are accepted by the blockchain. During this period, new cells created by the pending transaction are not available for new transactions. "),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"@ckb-lumos/transaction-manager")," package deals with this problem. The transaction manager wraps an indexer instance, and makes sure the cells that are created in pending transactions, are also exposed and available for new transactions. "),Object(a.b)("p",null,"You can get uncommitted outputs by the ",Object(a.b)("inlineCode",{parentName:"p"},"collector")," of the transaction manager."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/querycells.ts"',title:'"hellolumos/src/querycells.ts"'}),'import TransactionManager = require ("@ckb-lumos/transaction-manager");\nexport async function getUncommittedCells(\n  lockScript:Script\n): Promise<Cell[]>  {\n  const transactionmanager = new TransactionManager(INDEXER);\n  transactionmanager.start();\n\n  const cells:Cell[] = [];\n  console.log("Get uncommitted cells");\n  const collector = transactionmanager.collector( {lock:lockScript});\n  for await (const cell of collector.collect()) {\n    cells.push(cell);\n  }\n  return cells;\n}\n')))}b.isMDXComponent=!0}}]);