(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{110:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),l=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var i=l.a.createContext({}),p=function(e){var t=l.a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},b=function(e){var t=p(e.components);return l.a.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},d=l.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,i=s(e,["components","mdxType","originalType","parentName"]),b=p(n),d=a,m=b["".concat(o,".").concat(d)]||b[d]||u[d]||r;return n?l.a.createElement(m,c(c({ref:t},i),{},{components:n})):l.a.createElement(m,c({ref:t},i))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=d;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var i=2;i<r;i++)o[i]=n[i];return l.a.createElement.apply(null,o)}return l.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},93:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return p}));var a=n(3),l=n(7),r=(n(0),n(110)),o={id:"nftglue",title:"Integrating NFT Script on CKB"},c={unversionedId:"tutorials/nftglue",id:"tutorials/nftglue",isDocsHomePage:!1,title:"Integrating NFT Script on CKB",description:"Introduction",source:"@site/docs\\tutorials\\nftglue.md",slug:"/tutorials/nftglue",permalink:"/lumos_doc/docs/tutorials/nftglue",editUrl:"https://github.com/xying21/lumos_doc/tree/master/docs/tutorials/nftglue.md",version:"current",sidebar:"someSidebar",previous:{title:"Assemble Transactions",permalink:"/lumos_doc/docs/tutorials/buildtransactions"},next:{title:"Integrate Nervos DAO with DApps by Using Lumos",permalink:"/lumos_doc/docs/tutorials/usedao"}},s=[{value:"Introduction",id:"introduction",children:[]},{value:"Environment and Tools",id:"environment-and-tools",children:[]},{value:"Deploy the NFT Script on DEV Chain",id:"deploy-the-nft-script-on-dev-chain",children:[{value:"<strong>Step 1. Install and configure a DEV blockchain.</strong>",id:"step-1-install-and-configure-a-dev-blockchain",children:[]},{value:"<strong>Step 2. Install Docker on Ubuntu system and manage Docker as a non-root user.</strong>",id:"step-2-install-docker-on-ubuntu-system-and-manage-docker-as-a-non-root-user",children:[]},{value:"<strong>Step 3. Install Capsule.</strong>",id:"step-3-install-capsule",children:[]},{value:"<strong>Step 4. Add <code>ckb-cli</code> and Capsule to the PATH environment variable.</strong>",id:"step-4-add-ckb-cli-and-capsule-to-the-path-environment-variable",children:[]},{value:"<strong>Step 5. Check the Capsule installation.</strong>",id:"step-5-check-the-capsule-installation",children:[]},{value:"<strong>Step 6. Download the example code.</strong>",id:"step-6-download-the-example-code",children:[]},{value:"<strong>Step 7. Build the NFT script.</strong>",id:"step-7-build-the-nft-script",children:[]},{value:"Step 8. Deploy the script.",id:"step-8-deploy-the-script",children:[]}]},{value:"Operate on NFT Tokens by Using Lumos",id:"operate-on-nft-tokens-by-using-lumos",children:[{value:"Step 1. Install dependencies.",id:"step-1-install-dependencies",children:[]},{value:"Step 2. Update the config.json file.",id:"step-2-update-the-configjson-file",children:[]},{value:"Step 3. Update the <code>index.ts</code> file for NFT operations.",id:"step-3-update-the-indexts-file-for-nft-operations",children:[]}]}],i={toc:s};function p(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},i,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"introduction"},"Introduction"),Object(r.b)("p",null,"Non Fungible Tokens (NFTs) are tokens that are not interchangeable or necessarily of equal value, even if they are within the same token class. This includes digital collectibles, game items, and records of ownership of physical assets."),Object(r.b)("p",null,"For more information, see the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://talk.nervos.org/t/rfc-ckb-nft-draft-spec/4779"}),"RFC: CKB-NFT Draft Spec"),"."),Object(r.b)("p",null,"This tutorial includes two parts:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Deploy the NFT script on DEV chain"),Object(r.b)("li",{parentName:"ul"},"Operate on NFT tokens by using Lumos, that includes the following operations:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Generate an NFT token"),Object(r.b)("li",{parentName:"ul"},"Find all live NFT cells by NFT ID"),Object(r.b)("li",{parentName:"ul"},"List all live NFT cells by the lock script"),Object(r.b)("li",{parentName:"ul"},"Transfer NFT token.")))),Object(r.b)("p",null,"A ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=7ob-WL1eWrQ"}),"Video Walkthrough")," is also provided for an overview of the architecture and code walkthrough. "),Object(r.b)("h2",{id:"environment-and-tools"},"Environment and Tools"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"OS: Ubuntu 20.04.2"),Object(r.b)("li",{parentName:"ul"},"NodeJS  (v14.15.5)"),Object(r.b)("li",{parentName:"ul"},"Yarn (1.22.5)"),Object(r.b)("li",{parentName:"ul"},"GCC and make")),Object(r.b)("h2",{id:"deploy-the-nft-script-on-dev-chain"},"Deploy the NFT Script on DEV Chain"),Object(r.b)("h3",{id:"step-1-install-and-configure-a-dev-blockchain"},Object(r.b)("strong",{parentName:"h3"},"Step 1. Install and configure a DEV blockchain.")),Object(r.b)("p",null,"This example uses CKB (v0.40.0)."),Object(r.b)("p",null,"For more information, see ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://localhost:3000/lumos_doc/docs/tutorials/installckb"}),"Install and Configure a CKB DEV Blockchain"),"."),Object(r.b)("h3",{id:"step-2-install-docker-on-ubuntu-system-and-manage-docker-as-a-non-root-user"},Object(r.b)("strong",{parentName:"h3"},"Step 2. Install Docker on Ubuntu system and manage Docker as a non-root user.")),Object(r.b)("p",null,"For more information, see ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.docker.com/engine/install/ubuntu/"}),"Install Docker Engine on Ubuntu")," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.docker.com/engine/install/linux-postinstall/"}),"Manage Docker as a non-root user"),"."),Object(r.b)("h3",{id:"step-3-install-capsule"},Object(r.b)("strong",{parentName:"h3"},"Step 3. Install Capsule.")),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/capsule/releases/tag/v0.1.3"}),"The pre-built tools")," of Capsule can be downloaded for the installation."),Object(r.b)("p",null,"This example uses capsule_v0.1.3_x86_64-linux.tar.gz for Ubuntu system."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note"),": Some versions of Capsule are incompatible with this example. Version ",Object(r.b)("strong",{parentName:"p"},"0.1.3")," is verified and recommended."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ curl -LO https://github.com/nervosnetwork/capsule/releases/download/v0.1.3/capsule_v0.1.3_x86_64-linux.tar.gz\n$ tar xzf capsule_v0.1.3_x86_64-linux.tar.gz\n")),Object(r.b)("h3",{id:"step-4-add-ckb-cli-and-capsule-to-the-path-environment-variable"},Object(r.b)("strong",{parentName:"h3"},"Step 4. Add ",Object(r.b)("inlineCode",{parentName:"strong"},"ckb-cli")," and Capsule to the PATH environment variable.")),Object(r.b)("p",null,"To add the variable, add the lines ",Object(r.b)("inlineCode",{parentName:"p"},"export PATH=$PATH:/<path to the file>"),", to the end of the ",Object(r.b)("strong",{parentName:"p"},"~/.bashrc")," file for Bash shell."),Object(r.b)("p",null,"For example:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"ckb-cli: ",Object(r.b)("inlineCode",{parentName:"p"},"export PATH=$PATH:/home/username/ckb_v0.40.0_x86_64-unknown-linux-gnu"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Capsule: ",Object(r.b)("inlineCode",{parentName:"p"},"export PATH=$PATH:/home/username/capsule_v0.1.3_x86_64-linux")))),Object(r.b)("p",null,"The folder /home/username/ckb_v0.40.0_x86_64-unknown-linux-gnu contains the ckb tools installed in ",Object(r.b)("strong",{parentName:"p"},"step 1"),"."),Object(r.b)("p",null,"The folder /home/username/capsule_v0.1.3_x86_64-linux contains the Capsule tools installed in ",Object(r.b)("strong",{parentName:"p"},"step 2"),"."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note"),": The current user must have permissions to execute ckb-cli and Capsule. "),Object(r.b)("h3",{id:"step-5-check-the-capsule-installation"},Object(r.b)("strong",{parentName:"h3"},"Step 5. Check the Capsule installation.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ capsule check\n------------------------------\ndocker  installed\nckb-cli installed v0.40.0\n------------------------------\n")),Object(r.b)("h3",{id:"step-6-download-the-example-code"},Object(r.b)("strong",{parentName:"h3"},"Step 6. Download the example code.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ git clone https://github.com/nervosnetwork/dapps-on-ckb-workshop-code.git\n")),Object(r.b)("h3",{id:"step-7-build-the-nft-script"},Object(r.b)("strong",{parentName:"h3"},"Step 7. Build the NFT script.")),Object(r.b)("p",null,"The generated script binary is located in the ",Object(r.b)("inlineCode",{parentName:"p"},"dapps-on-ckb-workshop-code/nft-validator/build/debug")," folder."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ cd dapps-on-ckb-workshop-code/nft-validator\n$ capsule build\nBuilding contract nft-validator\n Downloading crates ...\n  Downloaded ckb-allocator v0.1.1\n  Downloaded cc v1.0.58\n  Downloaded ckb-std v0.4.1\n  Downloaded buddy-alloc v0.3.0\n   Compiling cfg-if v0.1.10\n   Compiling cc v1.0.58\n   Compiling buddy-alloc v0.3.0\n   Compiling blake2b-ref v0.1.0\n   Compiling molecule v0.6.0\n   Compiling ckb-allocator v0.1.1\n   Compiling ckb-standalone-types v0.0.1-pre.1\n   Compiling ckb-std v0.4.1\n   Compiling nft-validator v0.1.0 (/code/contracts/nft-validator)\n    Finished dev [unoptimized + debuginfo] target(s) in 58.96s\nDone\n")),Object(r.b)("h3",{id:"step-8-deploy-the-script"},"Step 8. Deploy the script."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note"),": The CKB node must be running before deploying the NFT script."),Object(r.b)("p",null,"If the node is not started, run ",Object(r.b)("inlineCode",{parentName:"p"},"ckb run -C devnet")," in another terminal to start the node."),Object(r.b)("p",null,"To deploy the NFT script:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Update the ",Object(r.b)("inlineCode",{parentName:"li"},"[lock]")," field in the nft-validator/",Object(r.b)("inlineCode",{parentName:"li"},"deployment.toml")," file with your lock script.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'# [[cells]]\n# name = "my_cell"\n# enable_type_id = false\n# location = { file = "build/release/my_cell" }\n\n# # Dep group cells\n# [[dep_groups]]\n# name = "my_dep_group"\n# cells = [\n#   "my_cell",\n#   "secp256k1_data"\n# ]\n\n# # Replace with your own lock if you want to unlock deployed cells.\n# # The deployment code_hash is secp256k1 lock\n[lock]\ncode_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"\nargs = "the address that you can unlock in the dev chain"\nhash_type = "type"\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Generate the release binary.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ capsule build --release\nBuilding contract nft-validator\n   Compiling cc v1.0.58\n   Compiling cfg-if v0.1.10\n   Compiling buddy-alloc v0.3.0\n   Compiling blake2b-ref v0.1.0\n   Compiling molecule v0.6.0\n   Compiling ckb-allocator v0.1.1\n   Compiling ckb-standalone-types v0.0.1-pre.1\n   Compiling ckb-std v0.4.1\n   Compiling nft-validator v0.1.0 (/code/contracts/nft-validator)\n    Finished release [optimized] target(s) in 17.31s\nDone\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Deploy the NFT script to DEV chain by using the ",Object(r.b)("inlineCode",{parentName:"p"},"capsule deploy --address <the deployer's address>")," command."),Object(r.b)("p",{parentName:"li"},"For details about creating accounts with CKB capacities for developing and testing purpose, see ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://localhost:3000/lumos_doc/docs/tutorials/createaccount"}),"Create an Account for CKB Transactions"),"."))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note"),": Remember the ",Object(r.b)("inlineCode",{parentName:"p"},"data_hash")," and ",Object(r.b)("inlineCode",{parentName:"p"},"tx_hash")," that will be used in later operations."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ capsule deploy --address ckt1qyqfsh757xdy5vahah474juhhy287kp7jdxq4eun2w\nDeployment plan:\n---\nmigrated_capacity: 0.0 (CKB)\nnew_occupied_capacity: 33669.0 (CKB)\ntxs_fee_capacity: 0.0001 (CKB)\ntotal_occupied_capacity: 33669.0 (CKB)\nrecipe:\n  cells:\n    - name: nft\n      index: 0\n      tx_hash: 0xd6ae484f45a6bc40a558db60e2b55d8621a4db1e20e6196e2bed01a1234ee34f\n      occupied_capacity: 33669.0 (CKB)\n      data_hash: 0xcd26ace6d4a532c005b6af13196a912bfed399007584dc6a256c72d8bac0fde2\n      type_id: ~\n  dep_groups: []\nConfirm deployment? (Yes/No)\ny\nPassword: \nsend cell_tx d6ae484f45a6bc40a558db60e2b55d8621a4db1e20e6196e2bed01a1234ee34f\nDeployment complete\n")),Object(r.b)("h2",{id:"operate-on-nft-tokens-by-using-lumos"},"Operate on NFT Tokens by Using Lumos"),Object(r.b)("p",null,"After the NFT script is deployed on DEV chain, perform the following steps to interact and operate on NFT tokens by using Lumos."),Object(r.b)("h3",{id:"step-1-install-dependencies"},"Step 1. Install dependencies."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ cd dapps-on-ckb-workshop-code/nft-glue\n$ yarn install\nyarn install v1.22.5\n[1/4] Resolving packages...\n[2/4] Fetching packages...\n[3/4] Linking dependencies...\n[4/4] Building fresh packages...\nDone in 13.02s.\n")),Object(r.b)("h3",{id:"step-2-update-the-configjson-file"},"Step 2. Update the config.json file."),Object(r.b)("p",null,'Add the following content in the config.json file for NFT script under the "DAO" script.'),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"CODE_HASH")," is the ",Object(r.b)("inlineCode",{parentName:"p"},"data_hash")," from the NFT script deployment recipe."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"TX_HASH")," is the ",Object(r.b)("inlineCode",{parentName:"p"},"tx_hash")," from the NFT script deployment recipe."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'    ,\n    "NFT": {\n      "CODE_HASH": "0xcd26ace6d4a532c005b6af13196a912bfed399007584dc6a256c72d8bac0fde2",\n      "HASH_TYPE": "type",\n      "TX_HASH": "0xd6ae484f45a6bc40a558db60e2b55d8621a4db1e20e6196e2bed01a1234ee34f",\n      "INDEX": "0x0",\n      "DEP_TYPE": "code"\n    }\n')),Object(r.b)("h3",{id:"step-3-update-the-indexts-file-for-nft-operations"},"Step 3. Update the ",Object(r.b)("inlineCode",{parentName:"h3"},"index.ts")," file for NFT operations."),Object(r.b)("h4",{id:"generate-nft-tokens"},"Generate NFT Tokens"),Object(r.b)("p",null,"This example only supports gathering capacities from one single wallet."),Object(r.b)("p",null,"To generate NFT tokens:"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 1. Insert a dummy NFT output cell.")," "),Object(r.b)("p",null,"The dummy cell is exactly the same as a normal cell, except that it uses all zeros as NFT ID. This way we can leverage Lumos' utility for providing input cells that accommodate the capacities required by the output cell. When input cells are created, we can then generate correct NFT ID based on the first input cell."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'import { normalizers } from "ckb-js-toolkit";\nimport {HexString,Hash,Address,Cell,CellDep,OutPoint,Script,core,utils} from "@ckb-lumos/base";\nimport {\n  parseAddress,\n  generateAddress,\n  sealTransaction,\n  TransactionSkeletonType,\n  TransactionSkeleton,\n} from "@ckb-lumos/helpers";\nimport { common, secp256k1Blake160 } from "@ckb-lumos/common-scripts";\n\n//fromAddress: Address,\n//governanceLock: Script,\n//owner: Address\n\nfunction buildNftTypeScript(governanceLock: Script): Script {\n  const hasher = new CKBHasher();\n  hasher.update(\n    core.SerializeScript(normalizers.NormalizeScript(governanceLock))\n  );\n  const hash = hasher.digestHex();\n  const NFT = CONFIG.SCRIPTS.NFT;\n  if (!NFT) {\n    throw new Error("NFT script is not configured!");\n  }\n  return {\n    code_hash: NFT.CODE_HASH,\n    hash_type: NFT.HASH_TYPE,\n    args: hash,\n  };\n}\n\nlet skeleton = TransactionSkeleton({ cellProvider: indexer });\nskeleton = skeleton.update("outputs", (outputs) => {\n  return outputs.push({\n    cell_output: {\n      capacity: "0x" + (BigInt(200) * BigInt(100000000)).toString(16),\n      lock: parseAddress(owner),\n      type: buildNftTypeScript(governanceLock),\n    },\n    data:\n      "0x0000000000000000000000000000000000000000000000000000000000000000",\n    out_point: undefined,\n    block_hash: undefined,\n  });\n});\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 2.  Mark the ",Object(r.b)("inlineCode",{parentName:"strong"},"outputs")," fields as fixed.")),Object(r.b)("p",null,"Lumos is designed to generate smaller transactions for optimizations of a normal workflow. That means the following two cases may happen: "),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Multiple output cells with the same owner might be merged together."),Object(r.b)("li",{parentName:"ol"},"Transferring to an address which has input cells in the transaction, might result in the input cells being removed to cancel the transfer operation.")),Object(r.b)("p",null,"Because NFT requires special output cell and stable input cell. To avoid further optimizations altering those fields, ",Object(r.b)("inlineCode",{parentName:"p"},"fixedEntries")," can be used to mark the fields as fixed."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'  skeleton = skeleton.update("fixedEntries", (fixedEntries) => {\n    return fixedEntries.push(\n      {\n        field: "outputs",\n        index: 0,\n      }\n    );\n  });\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 3. Inject input cells to the transaction to provide capacities needed by the newly created input cells.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"  skeleton = await secp256k1Blake160.injectCapacity(skeleton, 0, fromAddress);\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 4. Generate and fill in the correct NFT token ID.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const { CKBHasher } = utils;  \nconst hasher = new CKBHasher();\n  const inputCell = skeleton.get("inputs")!.get(0)!;\n  hasher.update(\n    core.SerializeCellInput(\n      normalizers.NormalizeCellInput({\n        previous_output: inputCell.out_point,\n        since: "0x0",\n      })\n    )\n  );\n  hasher.update("0x0000000000000000");\n  const nftId = hasher.digestHex();\n  skeleton = skeleton.update("outputs", (outputs) => {\n    return outputs.update(0, (output) => {\n      output.data = nftId;\n      return output;\n    });\n  });\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 5. Mark the first input cell as fixed, because the first input cell is used to generate NFT ID.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'  skeleton = skeleton.update("fixedEntries", (fixedEntries) => {\n    return fixedEntries.push(\n      {\n        field: "inputs",\n        index: 0,\n      }\n    );\n  });\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 6. Include NFT ",Object(r.b)("inlineCode",{parentName:"strong"},"cell_deps"),".")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'import { getConfig, initializeConfig } from "@ckb-lumos/config-manager";\nexport const CONFIG = getConfig();\n\nfunction buildNftCellDep(): CellDep {\n  const NFT = CONFIG.SCRIPTS.NFT;\n  if (!NFT) {\n    throw new Error("NFT script is not configured!");\n  }\n  return {\n    out_point: {\n      tx_hash: NFT.TX_HASH,\n      index: NFT.INDEX,\n    },\n    dep_type: NFT.DEP_TYPE,\n  };\n}\n\nskeleton = skeleton.update("cellDeps", (cellDeps) => {\n    return cellDeps.push(buildNftCellDep());\n  });\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 7. Add fee for the transaction.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// For simplicity, we hardcode 0.1 CKB as transaction fee here.\nconst FEE = BigInt(1*10**8); \nskeleton = await common.payFee(skeleton, [fromAddress], FEE);\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 8. Generate messages that are required in transaction signing phase.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"skeleton = common.prepareSigningEntries(skeleton, { config: CONFIG });\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 9. Sign the transaction.")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 10. Seal the transaction with the signatures.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"const tx = sealTransaction(skeleton, signatures);\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 11. Send the transaction.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"const txHash = await rpc.send_transaction(tx);\n")),Object(r.b)("h4",{id:"list-all-live-nft-cells"},"List All Live NFT Cells"),Object(r.b)("p",null,"Live NFT cells are the cells with the requested NFT type script."),Object(r.b)("p",null,"To list all current live NFT cells:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const collector = indexer.collector({\n  type: buildNftTypeScript(governanceLock),\n  data: "any",\n});\n\nconst results = [];\n// For simplicity, we are gathering all cells in a single array. Note this might\n// be slow in case the number of cells grows quite big. You might want to use\n// a stream based solution to fetch only cells you need from the async iterator.\nfor await (const cell of collector.collect()) {\n  results.push(cell);\n}\nreturn results;\n')),Object(r.b)("h4",{id:"find-live-nft-cells-by-nft-id"},"Find Live NFT Cells by NFT ID"),Object(r.b)("p",null,"To find the live NFT cells by NFT ID:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const collector = indexer.collector({\n  type: buildNftTypeScript(governanceLock),\n  data: nftId,\n});\nconst results = [];\n// For simplicity, we are gathering all cells in a single array. Note this might\n// be slow in case the number of cells grows quite big. You might want to use\n// a stream based solution to fetch only cells you need from the async iterator.\nfor await (const cell of collector.collect()) {\n  results.push(cell);\n}\nreturn results;\n")),Object(r.b)("h4",{id:"list-all-current-live-nft-cells-by-the-lock-script"},"List All Current Live NFT Cells by the Lock Script"),Object(r.b)("p",null,"To list all live NFT cells by the ",Object(r.b)("inlineCode",{parentName:"p"},"lock")," script:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"    const collector = indexer.collector({\n      lock: lockScript,\n      type: buildNftTypeScript(governanceLock),\n    });\n    const results = [];\n    // For simplicity, we are gathering all cells in a single array. Note this might\n    // be slow in case the number of cells grows quite big. You might want to use\n    // a stream based solution to fetch only cells you need from the async iterator.\n    for await (const cell of collector.collect()) {\n      results.push(cell);\n    }\n    return results;\n")),Object(r.b)("h4",{id:"transfer-nft-token-from-one-user-to-another-user"},"Transfer NFT Token from One User to Another User"),Object(r.b)("p",null,"To transfer NFT Token from one user to another user:"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 1. Insert input and output cell for the specified NFT.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'let skeleton = TransactionSkeleton({ cellProvider: indexer });\n  \n  skeleton = skeleton\n    .update("inputs", (inputs) => {\n      return inputs.push(nftCell);\n    })\n    .update("outputs", (outputs) => {\n      return outputs.push({\n        cell_output: {\n          capacity: nftCell.cell_output.capacity,\n          lock: parseAddress(toAddress),\n          type: nftCell.cell_output.type,\n        },\n        data: nftCell.data,\n        out_point: undefined,\n        block_hash: undefined,\n      });\n    });\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 2. Add ",Object(r.b)("inlineCode",{parentName:"strong"},"fixedEntries")," for the input and output NFT cells.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'  skeleton = skeleton.update("fixedEntries", (fixedEntries) => {\n    return fixedEntries.push(\n      {\n        field: "inputs",\n        index: 0,\n      },\n      {\n        field: "outputs",\n        index: 0,\n      }\n    );\n  });\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 3. Include NFT ",Object(r.b)("inlineCode",{parentName:"strong"},"cell_deps"),".")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'skeleton = skeleton.update("cellDeps", (cellDeps) => {\n    return cellDeps.push(buildNftCellDep());\n  });\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 4. Add a fee for the transaction.")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note"),": For simplicity, the token sender will pay for the transaction fee. So the token sender must have spare CKB capacities in addition to the NFT token."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"skeleton = await common.payFee(\n  skeleton,\n  [generateAddress(nftCell.cell_output.lock)],\n  FEE\n);\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 5. Generate messages that are required in transaction signing phase.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"})," skeleton = common.prepareSigningEntries(skeleton, { config: CONFIG });\n return skeleton;\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Step 6. Sign the transaction.")),Object(r.b)("p",null,"This example uses a secp256k1 tool to generate a signature based on the private key ",Object(r.b)("inlineCode",{parentName:"p"},"0x29159d8bb4b27704b168fc7fae70ffebf82164ce432b3f6b4c904a116a969f19"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const signatures = ["0x1cb952fd224d1d14d07af621587e91a65ccb051d55ed1371b3b66d4fe169cf7758173882e4c02587cb54054d2de287cbb1fdc2fc21d848d7b320ee8c5826479901"];\n')),Object(r.b)("p",null,"Step 7. Seal the transaction with returned signatures."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const tx = sealTransaction(skeleton, signatures);\n")),Object(r.b)("p",null,"Step 8. Send the transaction."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const txHash = await rpc.send_transaction(tx);\n")))}p.isMDXComponent=!0}}]);