(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{119:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),s=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=s.a.createContext({}),b=function(e){var t=s.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=b(e.components);return s.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},d=s.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,r=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=b(n),d=a,m=p["".concat(r,".").concat(d)]||p[d]||u[d]||l;return n?s.a.createElement(m,o(o({ref:t},c),{},{components:n})):s.a.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=d;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var c=2;c<l;c++)r[c]=n[c];return s.a.createElement.apply(null,r)}return s.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},99:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return i})),n.d(t,"default",(function(){return b}));var a=n(3),s=n(7),l=(n(0),n(119)),r={id:"buildtransactions",title:"Assemble Transactions"},o={unversionedId:"tutorials/buildtransactions",id:"tutorials/buildtransactions",isDocsHomePage:!1,title:"Assemble Transactions",description:"Lumos provides the TransactionSkeleton interface that significantly simplifies transaction assembling.",source:"@site/docs\\tutorials\\buildtransactions.md",slug:"/tutorials/buildtransactions",permalink:"/lumos_doc/docs/tutorials/buildtransactions",editUrl:"https://github.com/xying21/lumos_doc/tree/master/docs/tutorials/buildtransactions.md",version:"current",sidebar:"someSidebar",previous:{title:"Query on Transactions",permalink:"/lumos_doc/docs/tutorials/querytransactions"},next:{title:"Manage Keys",permalink:"/lumos_doc/docs/tutorials/managekeys"}},i=[{value:"TransactionSkeleton",id:"transactionskeleton",children:[]},{value:"General Workflow for Assembling a Transaction",id:"general-workflow-for-assembling-a-transaction",children:[]},{value:"Examples",id:"examples",children:[{value:"Transfer CKB in a Common Transaction",id:"transfer-ckb-in-a-common-transaction",children:[]},{value:"Deposit CKB to DAO",id:"deposit-ckb-to-dao",children:[]},{value:"List all DAO Cells",id:"list-all-dao-cells",children:[]},{value:"Withdraw a Cell from Nervos DAO",id:"withdraw-a-cell-from-nervos-dao",children:[]},{value:"Unlock a Withdrawn Cell",id:"unlock-a-withdrawn-cell",children:[]}]}],c={toc:i};function b(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"Lumos provides the ",Object(l.b)("inlineCode",{parentName:"p"},"TransactionSkeleton")," interface that significantly simplifies transaction assembling. "),Object(l.b)("h2",{id:"transactionskeleton"},"TransactionSkeleton"),Object(l.b)("p",null,"Each transaction skeleton corresponds to an action, and will be built into a single transaction that is ready to be submitted to CKB. ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/develop/packages/helpers/src/index.ts#L212"}),"TransactionSkeleton")," supports transaction assembling with the following conveniences:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"A well designed component must be able to query and include cells automatically to provide capacities required by the transaction."),Object(l.b)("li",{parentName:"ul"},"Individual script logic must be managed and respected by the general transaction skeleton."),Object(l.b)("li",{parentName:"ul"},"Scripts sharing the same behavior must be managed together in a unified interface. Developers can rely on abstractions instead of catering for every single detail.")),Object(l.b)("h2",{id:"general-workflow-for-assembling-a-transaction"},"General Workflow for Assembling a Transaction"),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"The DApp creates a transaction skeleton.")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"The DApp adds the fee for the transaction."),Object(l.b)("p",{parentName:"li"},Object(l.b)("strong",{parentName:"p"},"Note"),": It is also possible to have someone other than the sender to pay the fee. ")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"The DApp prepares the signing entries."),Object(l.b)("p",{parentName:"li"},"The signing entries are the data that the user's wallet needs to sign to provide valid witnesses for the input lock scripts. ")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"The DApp acquires the signature from a user wallet."),Object(l.b)("p",{parentName:"li"},"From the security perspective of a DApp, Lumos does not support built-in message signing. So the DApp needs to send the raw transaction "," to the user wallet to acquire signatures. The raw transaction contains all the cells and dependencies for the action and the data that needs to be signed."," ")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"The DApp seals the transaction."),Object(l.b)("p",{parentName:"li"},"The transaction with signatures is forwarded to the DApp. The DApp seals the transaction by adding the transaction signatures to the transaction structure. ")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"The DApp forwards this finalized transaction to the CKB network."),Object(l.b)("p",{parentName:"li"},"The DApp forwards the sealed transaction to the CKB network through the RPC interface."),Object(l.b)("p",{parentName:"li"},"Upon successful receipt, the CKB network returns the transaction hash to the DApp. The transaction hash is sent back to the client such that the client can track the transactions.")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"(Optional) The DApp gets the transaction status."),Object(l.b)("p",{parentName:"li"},"A transaction can be in one of the following status:"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"A ",Object(l.b)("strong",{parentName:"li"},"pending")," result means the node is aware of the transaction but the transaction is not confirmed yet. "),Object(l.b)("li",{parentName:"ul"},"A ",Object(l.b)("strong",{parentName:"li"},"proposed")," result means the node sees a transaction included in a block candidate that is not yet mined. "),Object(l.b)("li",{parentName:"ul"},"A ",Object(l.b)("strong",{parentName:"li"},"committed")," result means that the block involving the transaction has been mined and is officially on chain.")))),Object(l.b)("h2",{id:"examples"},"Examples"),Object(l.b)("h3",{id:"transfer-ckb-in-a-common-transaction"},"Transfer CKB in a Common Transaction"),Object(l.b)("p",null,"A common transaction can be built with the following steps:"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 1. Create a transaction skeleton.")),Object(l.b)("p",null,"Example: ",Object(l.b)("u",null,"hellolumos/src/buildTXs.ts/buildCommonTx()")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),'import { TransactionSkeleton, TransactionSkeletonType } from "@ckb-lumos/helpers";\nlet skeleton:TransactionSkeletonType = TransactionSkeleton({cellProvider: INDEXER});\nskeleton = await common.transfer(\n    skeleton,\n    [sender],\n    recipient,\n    BigInt(amount),\n    undefined,\n    undefined\n);\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 2. Add the fee for the transaction.")),Object(l.b)("p",null,"Example: ",Object(l.b)("u",null,"hellolumos/src/buildTXs.ts/buildCommonTx()")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),"skeleton = await common.payFee(\n   //@ts-ignore\n   skeleton,\n   [sender],\n   BigInt(txFee),\n)\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 3. Prepare the signing entries.")," "),Object(l.b)("p",null,"Example: ",Object(l.b)("u",null,"hellolumos/src/buildTXs.ts/buildCommonTx()")),Object(l.b)("p",null,"The ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/common-scripts/src/common.ts#L434"}),"prepareSigningEntries()")," function is used in the following example."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),"skeleton = common.prepareSigningEntries(skeleton);\n")),Object(l.b)("p",null,"The buildCommonTx function returns the raw transaction that requires signatures."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 4. Sign the transaction.")),Object(l.b)("p",null,"Lumos does not support built-in message signing. The DApp needs to send the raw transaction to the user wallet to acquire signatures. For simplicity and demonstration, this example uses the ecdsaSign function to generate the signatures for signing the transaction."),Object(l.b)("p",null,"Example: ",Object(l.b)("u",null,"hellolumos/src/buildTXs.ts/signandSeal()")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),'import { ecdsaSign } from "secp256k1";\n\nconst signatures = txskeleton\n    .get("signingEntries")\n    .map(({ message }) => {\n      const o = ecdsaSign(\n        new Uint8Array(new Reader(message).toArrayBuffer()),\n        new Uint8Array(new Reader(privatekey).toArrayBuffer())\n      );\n      const signature = new Uint8Array(65);\n      signature.set(o.signature, 0);\n      signature.set([o.recid], 64);\n      return new Reader(signature.buffer).serializeJson();\n    })\n    .toArray();\n')),Object(l.b)("details",null,Object(l.b)("summary",null,"CLICK ME"),Object(l.b)("p",null,Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"[  \n'0x4f73f26e51bee76d89edb74aee20e6fb2f8c670881f087aba04be80d7bd05117579d2bcfea3618d55473504e06586c10eecb76169d2ef0849c72e50a2f5d2b9500'\n]\n")))),Object(l.b)("p",null,"Another simple method is to use the HD wallet manager to generate a signature based on the private key of the account."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'const {key} = require("@ckb-lumos/hd");\nconst message = skeleton.get("signingEntries").get(0).message;\nconst signatures = key.signRecoverable(message, privateKey)\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 5. Seal the transaction with the signature.")),Object(l.b)("p",null,"Example: ",Object(l.b)("u",null,"hellolumos/src/buildTXs.ts/signandSeal()")),Object(l.b)("p",null,"The ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/develop/packages/helpers/src/index.ts#L257"}),"sealTransaction()")," function is used to seal the transaction."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),'import { sealTransaction } from "@ckb-lumos/helpers";\nconst tx = sealTransaction(txSkeleton, signatures);\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 6. Send this finalized transaction to the CKB network.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Note:")," There is one legacy issue in Lumos old versions, that Anyone-Can-Pay script must be available on the chain. If you encounter the error that Anyone-Can-Pay script is not available when sending transactions to DEV chain, just copy a dummy script into the config.json file under the root of the DApp project to fix the error."),Object(l.b)("p",null,"The ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/rpc/src/index.ts#L339"}),"send_transaction()")," function is used to send the transaction in the following example. The function send the transaction to chain and returns a hash for the transaction."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'import { RPC } from "@ckb-lumos/rpc";\nconst rpc = new RPC("http://127.0.0.1:8114");\nconst hash = await rpc.send_transaction(skeleton);\nconsole.log(hash);\n')),Object(l.b)("details",null,Object(l.b)("summary",null,"CLICK ME"),Object(l.b)("p",null,Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"'0x9a501e405653219aa8022132158820231aa5ecaff91c970b18d10fbad5ccc178'\n")))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 7. (Optional) Get the Transaction Status.")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="mydapp/src/buildTxs.ts"',title:'"mydapp/src/buildTxs.ts"'}),'const txWithStatus= await rpc.get_transaction(hash);\nconsole.log("Transaction status is:",txWithStatus.tx_status.status); \n')),Object(l.b)("h3",{id:"deposit-ckb-to-dao"},"Deposit CKB to DAO"),Object(l.b)("p",null,"Nervos DAO is a smart contract. Users can interact the same way as any smart contract on CKB with Nervos DAO. One function of Nervos DAO is to provide an dilution counter-measure for CKByte holders. By deposit in Nervos DAO, holders get proportional secondary rewards, which guarantee their holding are only affected by hardcapped primary issuance as in Bitcoin."),Object(l.b)("p",null,"For more information about Nervos DAO, see ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0023-dao-deposit-withdraw/0023-dao-deposit-withdraw.md"}),"RFC: Nervos DAO"),"."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 1. Assemble a TransactionSkeleton with the transaction fee and signing entries for the deposit transaction.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),": ",Object(l.b)("u",null,"hellolumos/src/buildTXs.ts/deposit2DAO()")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),'export async function deposit2DAO(\n    sender: string,\n    amount: bigint,\n    txFee: bigint\n):Promise<TransactionSkeletonType> {\n    let skeleton:TransactionSkeletonType = TransactionSkeleton({cellProvider: INDEXER});\n    //@ts-ignore\n    console.log("Deposit to DAO transaction");\n    skeleton = await dao.deposit(skeleton,sender,sender,BigInt(amount));\n    console.log(JSON.stringify(createTransactionFromSkeleton(skeleton), null, 2));\n    skeleton = await secp256k1Blake160.payFee(skeleton,sender,BigInt(txFee));\n    console.log(createTransactionFromSkeleton(skeleton).inputs.length);\n    skeleton = secp256k1Blake160.prepareSigningEntries(skeleton);\n    console.log("signingEntries:",skeleton.get("signingEntries").toArray());\n    return skeleton;\n}\n')),Object(l.b)("p",null,"The example creates a TransactionSkeleton with the cells provided by the indexer. The same address is used as the ",Object(l.b)("inlineCode",{parentName:"p"},"fromInfo")," and ",Object(l.b)("inlineCode",{parentName:"p"},"toAddress")," for the ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/common-scripts/src/dao.ts#L112"}),"deposit")," function. The deposited cells are frozen after the deposit operation."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),"let skeleton:TransactionSkeletonType = TransactionSkeleton({cellProvider: INDEXER});\nskeleton = await dao.deposit(skeleton,sender,sender,BigInt(amount));\n")),Object(l.b)("p",null,Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/nervosnetwork/lumos/blob/c3bd18e6baac9c283995f25d226a689970dc9537/packages/helpers/src/index.ts#L224"}),"createTransactionFromSkeleton")," can be used to build a final transaction. It can also be used to view the current skeleton."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),'import { createTransactionFromSkeleton } from "@ckb-lumos/helpers";\nconsole.log(JSON.stringify(createTransactionFromSkeleton(skeleton), null, 2));\n')),Object(l.b)("p",null,"The example uses an existing module, the secp256k1-blake160 lock script in common-scripts to build the transaction for the paying transaction fee action. In the example, the sender provides 0.1 CKB as the transaction fee."),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"The deposit action and the paying transaction fee action are using the same address (the sender address). If you checked the transaction skeleton after incurring fees, you can notice that the transaction skeleton has only one input for the two actions. Lumos can intelligently rewrite the change cells generated in the deposit action to pay enough transaction fee. ")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),"skeleton = await secp256k1Blake160.payFee(skeleton,sender,BigInt(txFee));\n")),Object(l.b)("p",null,"This example loops through the skeleton, and creates ",Object(l.b)("inlineCode",{parentName:"p"},"signingEntries")," by using the default secp256k1-blake160 lock script."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),"skeleton = secp256k1Blake160.prepareSigningEntries(skeleton);\n")),Object(l.b)("p",null,"Try the buildTXs() function in the Node.js REPL mode:"),Object(l.b)("details",null,Object(l.b)("summary",null,"CLICK ME"),Object(l.b)("p",null,Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"")))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 2. Sign the transaction with the private key by using the HD wallet manager.")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'import {key} from "@ckb-lumos/hd";\nconst privatekey = ALICE.PRIVATE_KEY;\nconst message = skeleton.get("signingEntries").get(0).message;\nconst signature = key.signRecoverable(message, privateKey);\n')),Object(l.b)("details",null,Object(l.b)("summary",null,"CLICK ME"),Object(l.b)("p",null,Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"signingEntries: [\n  {\n    type: 'witness_args_lock',\n    index: 0,\n    message: '0x15412513e78a45a183818a370f318de44176e016aa90b2cd459cc1688040a77b'\n  }\n]\n")))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 5. Seal the transaction.")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"const depsittx = sealTransaction(depositSkeleton, [depositSig]);\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 6. Send this finalized transaction to the CKB network")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'const deposithash = await rpc.send_transaction(depsittx);\nconsole.log("The deposit transaction hash is",deposithash)\n')),Object(l.b)("details",null,Object(l.b)("summary",null,"CLICK ME"),Object(l.b)("p",null,Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"The deposit transaction hash is 0x655bac89e443db42d48644f9fd89ddee70691f8e39ee4635c313375e8b2e6c0a\n")))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 7. Check the capacity of the account with the Testnet address.")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'$ ckb-cli wallet get-capacity --address "ckt1qyq8uqrxpw9tzg4u5waydrzmdmh8raqt0k8qmuetsf"\n')),Object(l.b)("p",null,"The deposited 200 CKB appears in the result."),Object(l.b)("details",null,Object(l.b)("summary",null,"CLICK ME"),Object(l.b)("p",null,Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"dao: 200.0 (CKB)\nfree: 35571260.54369496 (CKB)\nimmature: 8039101.70646172 (CKB)\ntotal: 35571660.54369496 (CKB)\n")))),Object(l.b)("h3",{id:"list-all-dao-cells"},"List all DAO Cells"),Object(l.b)("p",null,"Example: ",Object(l.b)("u",null,"hellolumos/src/buildTXs.ts/listDAOCells()")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),'export async function listDAOCells(\n    fromaddress: string,\n    celltype: "deposit" | "all" | "withdraw"\n) {\n    console.log("List the DAO cells of the celltype",celltype, "for the address", fromaddress);\n    //@ts-ignore\n    for await (const cell of dao.listDaoCells(INDEXER,fromaddress,celltype)) {\n         console.log(cell); \n    }\n}\n')),Object(l.b)("p",null,"Try the withdrawfromDAO() function in the Node.js REPL mode:"),Object(l.b)("details",null,Object(l.b)("summary",null,"CLICK ME"),Object(l.b)("p",null,Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"")))),Object(l.b)("h3",{id:"withdraw-a-cell-from-nervos-dao"},"Withdraw a Cell from Nervos DAO"),Object(l.b)("p",null,"Example: ",Object(l.b)("u",null,"hellolumos/src/buildTXs.ts/withdrawfromDAO()")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:'title="hellolumos/src/buildTXs.ts"',title:'"hellolumos/src/buildTXs.ts"'}),'export async function withdrawfromDAO(\n    cell: Cell,\n    frominfo: string,\n    txFee: bigint\n):Promise<TransactionSkeletonType> {\n    console.log("Withdraw a DAO cell for the address", frominfo);\n    let skeleton = TransactionSkeleton({ cellProvider: INDEXER });\n    skeleton = await dao.withdraw(skeleton, cell, frominfo);\n    skeleton = await secp256k1Blake160.payFee(skeleton, frominfo, BigInt(txFee));\n    skeleton = secp256k1Blake160.prepareSigningEntries(skeleton);\n    console.log("signingEntries:",skeleton.get("signingEntries").toArray());\n    return skeleton;\n}\n')),Object(l.b)("p",null,"Try the withdrawfromDAO() function in the Node.js REPL mode:"),Object(l.b)("details",null,Object(l.b)("summary",null,"CLICK ME"),Object(l.b)("p",null,Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"")))),Object(l.b)("h3",{id:"unlock-a-withdrawn-cell"},"Unlock a Withdrawn Cell"),Object(l.b)("p",null,"Example: ",Object(l.b)("u",null,"hellolumos/src/buildTXs.ts/unlockWithdraw()")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'export async function unlockWithdraw(\n    depositinput: Cell,\n    withdrawinput: Cell,\n    toaddress:string,\n    frominfo: string,\n    txFee: bigint\n) {\n    let skeleton = TransactionSkeleton({ cellProvider: INDEXER });\n    skeleton = await dao.unlock(skeleton,depositinput,withdrawinput,toaddress,frominfo);\n    skeleton = await secp256k1Blake160.payFee(skeleton, frominfo, BigInt(txFee));\n    skeleton = secp256k1Blake160.prepareSigningEntries(skeleton);\n    console.log("signingEntries:",skeleton.get("signingEntries").toArray());\n    return skeleton;\n}\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Note"),": The withdraw cell can only be successfully unlocked after the lock period of the cell passed. Otherwise this function would throw an error. The lock period is 180 epoches."),Object(l.b)("p",null," Try the unlockWithdraw() function in the Node.js REPL mode:"),Object(l.b)("details",null,Object(l.b)("summary",null,"CLICK ME"),Object(l.b)("p",null,Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"")))))}b.isMDXComponent=!0}}]);