(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{111:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return o})),n.d(t,"default",(function(){return p}));var r=n(3),a=n(7),l=(n(0),n(125)),s={id:"nft",title:"NFT"},c={unversionedId:"concepts/nft",id:"concepts/nft",isDocsHomePage:!1,title:"NFT",description:"Non Fungible Tokens (NFTs) are tokens that are not interchangeable or necessarily of equal value, even if they are within the same token class. This includes digital collectibles, game items, and records of ownership of physical assets.",source:"@site/docs\\concepts\\nft.md",slug:"/concepts/nft",permalink:"/lumos_doc/docs/concepts/nft",editUrl:"https://github.com/xying21/lumos_doc/tree/master/docs/concepts/nft.md",version:"current"},o=[{value:"Generate NFT Tokens",id:"generate-nft-tokens",children:[]},{value:"List All Live NFT Cells",id:"list-all-live-nft-cells",children:[]},{value:"Find Live NFT Cells by NFT ID",id:"find-live-nft-cells-by-nft-id",children:[]},{value:"List All Current Live NFT Cells by the Lock Script",id:"list-all-current-live-nft-cells-by-the-lock-script",children:[]},{value:"Transfer NFT Token from One User to Another User",id:"transfer-nft-token-from-one-user-to-another-user",children:[]}],i={toc:o};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(l.b)("wrapper",Object(r.a)({},i,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"Non Fungible Tokens (NFTs) are tokens that are not interchangeable or necessarily of equal value, even if they are within the same token class. This includes digital collectibles, game items, and records of ownership of physical assets."),Object(l.b)("p",null,"For more information, see the ",Object(l.b)("a",{parentName:"p",href:"https://talk.nervos.org/t/rfc-ckb-nft-draft-spec/4779"},"RFC: CKB-NFT Draft Spec"),"."),Object(l.b)("p",null,"In this tutorial, we are going to generate an NFT token, find all live NFT cells by NFT ID, list all live NFT cells by the lock script and transfer NFT token."),Object(l.b)("h2",{id:"generate-nft-tokens"},"Generate NFT Tokens"),Object(l.b)("p",null,"This example only supports gathering capacities from one single wallet."),Object(l.b)("p",null,"To generate NFT tokens:"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 1. Insert a dummy NFT output cell.")," "),Object(l.b)("p",null,"The dummy cell is exactly the same as a normal cell, except that it uses all zeros as NFT ID. This way we can leverage Lumos' utility for providing input cells that accommodate the capacities required by the output cell. When input cells are created, we can then generate correct NFT ID based on the first input cell."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'import { normalizers } from "ckb-js-toolkit";\nimport {HexString,Hash,Address,Cell,CellDep,OutPoint,Script,core,utils} from "@ckb-lumos/base";\nimport {\n  parseAddress,\n  generateAddress,\n  sealTransaction,\n  TransactionSkeletonType,\n  TransactionSkeleton,\n} from "@ckb-lumos/helpers";\nimport { common, secp256k1Blake160 } from "@ckb-lumos/common-scripts";\n\n//fromAddress: Address,\n//governanceLock: Script,\n//owner: Address\n\nfunction buildNftTypeScript(governanceLock: Script): Script {\n  const hasher = new CKBHasher();\n  hasher.update(\n    core.SerializeScript(normalizers.NormalizeScript(governanceLock))\n  );\n  const hash = hasher.digestHex();\n  const NFT = CONFIG.SCRIPTS.NFT;\n  if (!NFT) {\n    throw new Error("NFT script is not configured!");\n  }\n  return {\n    code_hash: NFT.CODE_HASH,\n    hash_type: NFT.HASH_TYPE,\n    args: hash,\n  };\n}\n\nlet skeleton = TransactionSkeleton({ cellProvider: indexer });\nskeleton = skeleton.update("outputs", (outputs) => {\n  return outputs.push({\n    cell_output: {\n      capacity: "0x" + (BigInt(200) * BigInt(100000000)).toString(16),\n      lock: parseAddress(owner),\n      type: buildNftTypeScript(governanceLock),\n    },\n    data:\n      "0x0000000000000000000000000000000000000000000000000000000000000000",\n    out_point: undefined,\n    block_hash: undefined,\n  });\n});\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 2.  Mark the ",Object(l.b)("inlineCode",{parentName:"strong"},"outputs")," fields as fixed.")),Object(l.b)("p",null,"Lumos is designed to generate smaller transactions for optimizations of a normal workflow. That means the following two cases may happen: "),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"Multiple output cells with the same owner might be merged together."),Object(l.b)("li",{parentName:"ol"},"Transferring to an address which has input cells in the transaction, might result in the input cells being removed to cancel the transfer operation.")),Object(l.b)("p",null,"Because NFT requires special output cell and stable input cell. To avoid further optimizations altering those fields, ",Object(l.b)("inlineCode",{parentName:"p"},"fixedEntries")," can be used to mark the fields as fixed."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'  skeleton = skeleton.update("fixedEntries", (fixedEntries) => {\n    return fixedEntries.push(\n      {\n        field: "outputs",\n        index: 0,\n      }\n    );\n  });\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 3. Inject input cells to the transaction to provide capacities needed by the newly created input cells.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"  skeleton = await secp256k1Blake160.injectCapacity(skeleton, 0, fromAddress);\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 4. Generate and fill in the correct NFT token ID.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'const { CKBHasher } = utils;  \nconst hasher = new CKBHasher();\n  const inputCell = skeleton.get("inputs")!.get(0)!;\n  hasher.update(\n    core.SerializeCellInput(\n      normalizers.NormalizeCellInput({\n        previous_output: inputCell.out_point,\n        since: "0x0",\n      })\n    )\n  );\n  hasher.update("0x0000000000000000");\n  const nftId = hasher.digestHex();\n  skeleton = skeleton.update("outputs", (outputs) => {\n    return outputs.update(0, (output) => {\n      output.data = nftId;\n      return output;\n    });\n  });\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 5. Mark the first input cell as fixed, because the first input cell is used to generate NFT ID.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'  skeleton = skeleton.update("fixedEntries", (fixedEntries) => {\n    return fixedEntries.push(\n      {\n        field: "inputs",\n        index: 0,\n      }\n    );\n  });\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 6. Include NFT ",Object(l.b)("inlineCode",{parentName:"strong"},"cell_deps"),".")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'import { getConfig, initializeConfig } from "@ckb-lumos/config-manager";\nexport const CONFIG = getConfig();\n\nfunction buildNftCellDep(): CellDep {\n  const NFT = CONFIG.SCRIPTS.NFT;\n  if (!NFT) {\n    throw new Error("NFT script is not configured!");\n  }\n  return {\n    out_point: {\n      tx_hash: NFT.TX_HASH,\n      index: NFT.INDEX,\n    },\n    dep_type: NFT.DEP_TYPE,\n  };\n}\n\nskeleton = skeleton.update("cellDeps", (cellDeps) => {\n    return cellDeps.push(buildNftCellDep());\n  });\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 7. Add fee for the transaction.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"// For simplicity, we hardcode 0.1 CKB as transaction fee here.\nconst FEE = BigInt(1*10**8); \nskeleton = await common.payFee(skeleton, [fromAddress], FEE);\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 8. Generate messages that are required in transaction signing phase.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-typescript"},"skeleton = common.prepareSigningEntries(skeleton, { config: CONFIG });\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 9. Sign the transaction.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 10. Seal the transaction with the signatures.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-typescript"},"const tx = sealTransaction(skeleton, signatures);\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 11. Send the transaction.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-typescript"},"const txHash = await rpc.send_transaction(tx);\n")),Object(l.b)("h2",{id:"list-all-live-nft-cells"},"List All Live NFT Cells"),Object(l.b)("p",null,"Live NFT cells are the cells with the requested NFT type script."),Object(l.b)("p",null,"To list all current live NFT cells:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'const collector = indexer.collector({\n  type: buildNftTypeScript(governanceLock),\n  data: "any",\n});\n\nconst results = [];\n// For simplicity, we are gathering all cells in a single array. Note this might\n// be slow in case the number of cells grows quite big. You might want to use\n// a stream based solution to fetch only cells you need from the async iterator.\nfor await (const cell of collector.collect()) {\n  results.push(cell);\n}\nreturn results;\n')),Object(l.b)("h2",{id:"find-live-nft-cells-by-nft-id"},"Find Live NFT Cells by NFT ID"),Object(l.b)("p",null,"To find the live NFT cells by NFT ID:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"const collector = indexer.collector({\n  type: buildNftTypeScript(governanceLock),\n  data: nftId,\n});\nconst results = [];\n// For simplicity, we are gathering all cells in a single array. Note this might\n// be slow in case the number of cells grows quite big. You might want to use\n// a stream based solution to fetch only cells you need from the async iterator.\nfor await (const cell of collector.collect()) {\n  results.push(cell);\n}\nreturn results;\n")),Object(l.b)("h2",{id:"list-all-current-live-nft-cells-by-the-lock-script"},"List All Current Live NFT Cells by the Lock Script"),Object(l.b)("p",null,"To list all live NFT cells by the ",Object(l.b)("inlineCode",{parentName:"p"},"lock")," script:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"    const collector = indexer.collector({\n      lock: lockScript,\n      type: buildNftTypeScript(governanceLock),\n    });\n    const results = [];\n    // For simplicity, we are gathering all cells in a single array. Note this might\n    // be slow in case the number of cells grows quite big. You might want to use\n    // a stream based solution to fetch only cells you need from the async iterator.\n    for await (const cell of collector.collect()) {\n      results.push(cell);\n    }\n    return results;\n")),Object(l.b)("h2",{id:"transfer-nft-token-from-one-user-to-another-user"},"Transfer NFT Token from One User to Another User"),Object(l.b)("p",null,"To transfer NFT Token from one user to another user:"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 1. Insert input and output cell for the specified NFT.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'let skeleton = TransactionSkeleton({ cellProvider: indexer });\n  \n  skeleton = skeleton\n    .update("inputs", (inputs) => {\n      return inputs.push(nftCell);\n    })\n    .update("outputs", (outputs) => {\n      return outputs.push({\n        cell_output: {\n          capacity: nftCell.cell_output.capacity,\n          lock: parseAddress(toAddress),\n          type: nftCell.cell_output.type,\n        },\n        data: nftCell.data,\n        out_point: undefined,\n        block_hash: undefined,\n      });\n    });\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 2. Add ",Object(l.b)("inlineCode",{parentName:"strong"},"fixedEntries")," for the input and output NFT cells.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'  skeleton = skeleton.update("fixedEntries", (fixedEntries) => {\n    return fixedEntries.push(\n      {\n        field: "inputs",\n        index: 0,\n      },\n      {\n        field: "outputs",\n        index: 0,\n      }\n    );\n  });\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 3. Include NFT ",Object(l.b)("inlineCode",{parentName:"strong"},"cell_deps"),".")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'skeleton = skeleton.update("cellDeps", (cellDeps) => {\n    return cellDeps.push(buildNftCellDep());\n  });\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 4. Add a fee for the transaction.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Note"),": For simplicity, the token sender will pay for the transaction fee. So the token sender must have spare CKB capacities in addition to the NFT token."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"skeleton = await common.payFee(\n  skeleton,\n  [generateAddress(nftCell.cell_output.lock)],\n  FEE\n);\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 5. Generate messages that are required in transaction signing phase.")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"}," skeleton = common.prepareSigningEntries(skeleton, { config: CONFIG });\n return skeleton;\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Step 6. Sign the transaction.")),Object(l.b)("p",null,"This example uses a secp256k1 tool to generate a signature based on the private key ",Object(l.b)("inlineCode",{parentName:"p"},"0x29159d8bb4b27704b168fc7fae70ffebf82164ce432b3f6b4c904a116a969f19"),"."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},'const signatures = ["0x1cb952fd224d1d14d07af621587e91a65ccb051d55ed1371b3b66d4fe169cf7758173882e4c02587cb54054d2de287cbb1fdc2fc21d848d7b320ee8c5826479901"];\n')),Object(l.b)("p",null,"Step 7. Seal the transaction with returned signatures."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"const tx = sealTransaction(skeleton, signatures);\n")),Object(l.b)("p",null,"Step 8. Send the transaction."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"const txHash = await rpc.send_transaction(tx);\n")))}p.isMDXComponent=!0},125:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return f}));var r=n(0),a=n.n(r);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=a.a.createContext({}),p=function(e){var t=a.a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=p(e.components);return a.a.createElement(i.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,i=o(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,f=u["".concat(s,".").concat(d)]||u[d]||b[d]||l;return n?a.a.createElement(f,c(c({ref:t},i),{},{components:n})):a.a.createElement(f,c({ref:t},i))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=d;var c={};for(var o in t)hasOwnProperty.call(t,o)&&(c[o]=t[o]);c.originalType=e,c.mdxType="string"==typeof e?e:r,s[1]=c;for(var i=2;i<l;i++)s[i]=n[i];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);